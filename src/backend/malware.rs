use std::collections::HashMap;
use std::fmt;

use serde::{self, Serialize};
use serde::ser::Serializer;
use serde::de::{self, Deserialize, Deserializer};
use thiserror::Error;

use super::mathphysics::{Millisecond, PowerUnit};


// `InfectionMap` maps malware to the timestamp when a device was infected with
// this malware.
pub type InfectionMap = HashMap<Malware, Millisecond>;


const MALWARE_DISPLAY_DELIMITER: &str         = "-";
const MALWARE_DISPLAY_SPREAD_DELAY_NONE: &str = "None";

const ERR_MISSING_MW_TYPE: &str      = "Missing malware type";
const ERR_MISSING_INF_DELAY: &str    = "Missing infection delay";
const ERR_MISSING_SPREAD_DELAY: &str = "Missing spread delay";
const ERR_PARSE_MW_TYPE: &str        = "Failed to parse malware type";
const ERR_PARSE_INF_DELAY: &str      = "Failed to parse infection delay";
const ERR_PARSE_SPREAD_DELAY: &str   = "Failed to parse spread delay";


#[derive(Debug, Error)]
pub enum MalwareTypeParseError {
    #[error("Incorred DoS format")]
    IncorrectDoSFormat,
    #[error("Unsupported malware type")]
    UnknownType,
}

#[derive(Debug, Error)]
pub enum SpreadDelayParseError {
    #[error("Failed to parse the string")]
    FailedToParse
}


fn malware_type_from_str(
    malware_type_str: &str
) -> Result<MalwareType, MalwareTypeParseError> {
    if malware_type_str == "Indicator" {
        return Ok(MalwareType::Indicator);
    }

    let power_string = malware_type_str
        .strip_prefix("DoS(")
        .and_then(|s| s.strip_suffix(")"))
        .ok_or(MalwareTypeParseError::UnknownType)?;
    let power: PowerUnit = power_string
        .parse()
        .map_err(|_| MalwareTypeParseError::IncorrectDoSFormat)?;

    Ok(MalwareType::DoS(power))
}

fn spread_delay_from_str(
    spread_delay_str: &str
) -> Result<Option<Millisecond>, SpreadDelayParseError> {
    if spread_delay_str == MALWARE_DISPLAY_SPREAD_DELAY_NONE {
        return Ok(None);
    }

    let spread_delay: Millisecond = spread_delay_str
        .parse()
        .map_err(|_| SpreadDelayParseError::FailedToParse)?;

    Ok(Some(spread_delay))
}


#[derive(Clone, Copy, Debug, derive_more::Display, Eq, Hash, PartialEq)]
pub enum MalwareType { 
    #[display("DoS({_0})")]
    DoS(PowerUnit),
    #[display("Indicator")]
    Indicator,
}


#[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]
pub struct Malware {
    malware_type: MalwareType,
    infection_delay: Millisecond,
    spread_delay: Option<Millisecond>, // If `None`, malware does not spread.
}

impl Malware {
    #[must_use]
    pub fn new(
        malware_type: MalwareType,
        infection_delay: Millisecond,
        spread_delay: Option<Millisecond>,
    ) -> Self {
        Self {
            malware_type,
            infection_delay,
            spread_delay,
        }
    }

    #[must_use]
    pub fn malware_type(&self) -> &MalwareType {
        &self.malware_type
    }

    #[must_use]
    pub fn infection_delay(&self) -> Millisecond {
        self.infection_delay
    }

    #[must_use]
    pub fn spreads(&self) -> bool {
        self.spread_delay.is_some()
    }
    
    #[must_use]
    pub fn spread_delay(&self) -> Option<Millisecond> {
        self.spread_delay
    }
}

impl fmt::Display for Malware {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let spread_delay_str = match self.spread_delay {
            Some(spread_delay) => &format!("{spread_delay}"),
            None               => MALWARE_DISPLAY_SPREAD_DELAY_NONE,
        };

        let malware_string = format!(
            "{}{}{}{}{}",
            self.malware_type,
            MALWARE_DISPLAY_DELIMITER,
            self.infection_delay,
            MALWARE_DISPLAY_DELIMITER,
            spread_delay_str,
        );

        write!(f, "{malware_string}")
    }
}

impl Serialize for Malware {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer 
    {
        serializer.serialize_str(&format!("{self}"))
    }
}

impl<'de> Deserialize<'de> for Malware {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        let mut parts = data.split(MALWARE_DISPLAY_DELIMITER);
        
        let malware_type = parts
            .next()
            .map_or_else(
                || Err(de::Error::custom(ERR_MISSING_MW_TYPE)),
                |malware_type_str| malware_type_from_str(malware_type_str)
                    .map_err(|_| de::Error::custom(ERR_PARSE_MW_TYPE))
            )?;
        
        let infection_delay: Millisecond = parts
            .next()
            .ok_or_else(|| de::Error::custom(ERR_MISSING_INF_DELAY))?
            .parse()
            .map_err(|_| de::Error::custom(ERR_PARSE_INF_DELAY))?;
        
        let spread_delay = parts
            .next()
            .map_or_else(
                || Err(de::Error::custom(ERR_MISSING_SPREAD_DELAY)),
                |spread_delay_str| spread_delay_from_str(spread_delay_str)
                    .map_err(|_| de::Error::custom(ERR_PARSE_SPREAD_DELAY))
            )?;

        Ok(Self { malware_type, infection_delay, spread_delay })
    }
}
