use std::collections::HashMap;

use serde::{Deserialize, Serialize};

use super::signal::{SignalLevel, YELLOW_SIGNAL_LEVEL};
use super::mathphysics::{Millisecond, PowerUnit};


// Here a key is a malware, and a value is a tuple where
// * the first element - time of infection with the malware.
// * the second element - infection state of the malware.
pub type MalwareToStateMap = HashMap<Malware, (Millisecond, InfectionState)>;


pub const JAMMING_SIGNAL_LEVEL: SignalLevel = YELLOW_SIGNAL_LEVEL;


#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum InfectionState {
    Vulnerable,
    Infected,
    Patched
}


#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq, Serialize, Deserialize)]
pub enum MalwareType { 
    DoS(PowerUnit),
    Indicator,
}


#[derive(Debug, Clone, Copy, Eq, PartialEq, Hash, Serialize, Deserialize)]
pub struct Malware {
    malware_type: MalwareType,
    infection_delay: Millisecond,
    // If `None`, malware does not spread.
    spread_delay: Option<Millisecond>,
}

impl Malware {
    #[must_use]
    pub fn new(
        malware_type: MalwareType,
        infection_delay: Millisecond,
        spread_delay: Option<Millisecond>,
    ) -> Self {
        Self {
            malware_type,
            infection_delay,
            spread_delay,
        }
    }

    #[must_use]
    pub fn malware_type(&self) -> &MalwareType {
        &self.malware_type
    }

    #[must_use]
    pub fn infection_delay(&self) -> Millisecond {
        self.infection_delay
    }

    #[must_use]
    pub fn spreads(&self) -> bool {
        self.spread_delay.is_some()
    }
    
    #[must_use]
    pub fn spread_delay(&self) -> Option<Millisecond> {
        self.spread_delay
    }
}
