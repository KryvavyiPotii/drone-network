use std::collections::HashMap;

use serde::{self, Serialize};
use serde::ser::Serializer;
use serde::de::{self, Deserialize, Deserializer};
use thiserror::Error;

use super::signal::{SignalLevel, YELLOW_SIGNAL_LEVEL};
use super::mathphysics::{Millisecond, PowerUnit};


// Here a key is a malware, and a value is a tuple where
// * the first element - time of infection with the malware.
// * the second element - infection state of the malware.
pub type MalwareToStateMap = HashMap<Malware, (Millisecond, InfectionState)>;


pub const JAMMING_SIGNAL_LEVEL: SignalLevel = YELLOW_SIGNAL_LEVEL;

const MALWARE_DISPLAY_DELIMITER: &str = "-";


#[derive(Debug, Error)]
pub enum MalwareTypeParseError {
    #[error("Incorred DoS format")]
    IncorrectDoSFormat,
    #[error("Unsupported malware type")]
    UnknownType,
}


fn string_from_malware_type(malware_type: &MalwareType) -> String {
    match malware_type {
        MalwareType::DoS(power) => format!("DoS({power})"),
        MalwareType::Indicator  => format!("Indicator"),
    }
}

fn malware_type_from_str(
    malware_type_str: &str
) -> Result<MalwareType, MalwareTypeParseError> {
    if malware_type_str == "Indicator" {
        return Ok(MalwareType::Indicator);
    }

    let power_string = malware_type_str
        .strip_prefix("DoS(")
        .and_then(|s| s.strip_suffix(")"))
        .ok_or(MalwareTypeParseError::UnknownType)?;
    let power: PowerUnit = power_string
        .parse()
        .map_err(|_| MalwareTypeParseError::IncorrectDoSFormat)?;

    Ok(MalwareType::DoS(power))
}


#[derive(Debug, Clone, Copy, serde::Deserialize, Serialize)]
pub enum InfectionState {
    Vulnerable,
    Infected,
    Patched
}


#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
pub enum MalwareType { 
    DoS(PowerUnit),
    Indicator,
}


#[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]
pub struct Malware {
    malware_type: MalwareType,
    infection_delay: Millisecond,
    // If `None`, malware does not spread.
    spread_delay: Option<Millisecond>,
}

impl Malware {
    #[must_use]
    pub fn new(
        malware_type: MalwareType,
        infection_delay: Millisecond,
        spread_delay: Option<Millisecond>,
    ) -> Self {
        Self {
            malware_type,
            infection_delay,
            spread_delay,
        }
    }

    #[must_use]
    pub fn malware_type(&self) -> &MalwareType {
        &self.malware_type
    }

    #[must_use]
    pub fn infection_delay(&self) -> Millisecond {
        self.infection_delay
    }

    #[must_use]
    pub fn spreads(&self) -> bool {
        self.spread_delay.is_some()
    }
    
    #[must_use]
    pub fn spread_delay(&self) -> Option<Millisecond> {
        self.spread_delay
    }
}

impl Serialize for Malware {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer 
    {
        let mut malware_string = format!(
            "{}{}{}", 
            string_from_malware_type(&self.malware_type),
            MALWARE_DISPLAY_DELIMITER,
            self.infection_delay, 
        );

        if let Some(spread_delay) = self.spread_delay {
            let spread_delay_string = format!(
                "{}{}",
                MALWARE_DISPLAY_DELIMITER,
                spread_delay
            );

            malware_string.push_str(&spread_delay_string);
        }

        serializer.serialize_str(&malware_string)
    }
}

impl<'de> Deserialize<'de> for Malware {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let data = <&str>::deserialize(deserializer)?;
        
        let mut parts = data.split(MALWARE_DISPLAY_DELIMITER);
        
        let malware_type = if let Some(malware_type_str) = parts.next() {
            if let Ok(malware_type) = malware_type_from_str(malware_type_str) {
                malware_type
            } else {
                return Err(de::Error::custom("Invalid malware type"));
            }
        } else {
            return Err(de::Error::custom("Missing malware type"));
        };
        
        let infection_delay = if let Some(infection_delay_str) = parts.next() {
            if let Ok(infection_delay) = infection_delay_str
                .parse::<Millisecond>()
            {
                infection_delay
            } else {
                return Err(de::Error::custom("Incorrect delimiter"));
            }
        } else {
            return Err(de::Error::custom("Failed to parse infection delay"));
        };
        
        let spread_delay = if let Some(spread_delay_str) = parts.next() {
            if let Ok(spread_delay) = spread_delay_str.parse::<Millisecond>() {
                Some(spread_delay)
            } else {
                return Err(de::Error::custom("Failed to parse spread delay"));
            }
        } else {
            None
        };

        Ok(Self { malware_type, infection_delay, spread_delay })
    }
}
